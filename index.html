<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Advisor Performance ‚Äì Service Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- PapaParse for CSV loading -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root {
      --bg: #050510;
      --bg-alt: #0b0b1a;
      --card: #111827;
      --card-soft: radial-gradient(circle at top left, #1f2937 0, #020617 55%);
      --accent: #00bcd4;
      --accent-soft: #00bcd466;
      --text: #f9fafb;
      --muted: #9ca3af;
      --border: #1f2937;
      --danger: #f97373;
      --success: #22c55e;
      --warning: #facc15;
      --shadow-soft: 0 18px 40px rgba(15, 23, 42, 0.88);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top left, #111827 0, #020617 55%);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .shell {
      width: min(1200px, 96%);
      margin: 20px auto 40px;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .title-block {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .pulse-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--accent);
      box-shadow: 0 0 14px var(--accent-soft);
    }

    h1 {
      margin: 0;
      font-size: clamp(20px, 2.4vw, 26px);
      font-weight: 600;
    }

    .subtitle {
      font-size: 11px;
      color: var(--muted);
      max-width: 560px;
    }

    .header-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
    }

    select,
    input[type="date"] {
      background: #020617;
      border-radius: 999px;
      border: 1px solid var(--border);
      padding: 6px 10px;
      font-size: 12px;
      color: var(--text);
      outline: none;
      min-width: 130px;
    }

    button {
      border: none;
      border-radius: 999px;
      font-size: 12px;
      padding: 8px 14px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #020617;
      color: var(--text);
      border: 1px solid var(--border);
      transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.15s ease;
    }

    button:hover {
      background: #020617;
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(15, 23, 42, 0.9);
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent), #38bdf8);
      border-color: transparent;
      color: #020617;
      font-weight: 600;
      box-shadow: 0 10px 22px rgba(0, 188, 212, 0.5);
    }

    .btn-primary:hover {
      box-shadow: 0 14px 26px rgba(0, 188, 212, 0.7);
    }

    .icon-btn {
      width: 34px;
      height: 34px;
      justify-content: center;
      padding: 0;
      font-size: 16px;
    }

    .top-tabs {
      margin-top: 10px;
      margin-bottom: 10px;
      display: inline-flex;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid var(--border);
      padding: 4px;
    }

    .top-tab {
      border-radius: 999px;
      padding: 6px 18px;
      font-size: 12px;
      cursor: pointer;
      color: var(--muted);
      border: none;
      background: transparent;
      transition: background 0.15s ease, color 0.15s ease;
    }

    .top-tab.active {
      background: linear-gradient(135deg, #1e293b, #020617);
      color: #e5e7eb;
    }

    .section-title {
      margin: 16px 0 8px;
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .gauge-row {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
    }

    @media (max-width: 960px) {
      .gauge-row {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 640px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }
      .header-controls {
        width: 100%;
        justify-content: flex-start;
      }
      .gauge-row {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .card {
      position: relative;
      background: var(--card-soft);
      border-radius: 18px;
      border: 1px solid var(--border);
      padding: 12px 12px 14px;
      box-shadow: var(--shadow-soft);
      overflow: hidden;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    .card-title {
      font-size: 13px;
      font-weight: 500;
    }

    .pill {
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      color: var(--muted);
    }

    .pill.good {
      border-color: rgba(34, 197, 94, 0.7);
      color: #bbf7d0;
      background: rgba(22, 163, 74, 0.18);
    }

    .pill.bad {
      border-color: rgba(248, 113, 113, 0.8);
      color: #fecaca;
      background: rgba(239, 68, 68, 0.16);
    }

    .card-main-value {
      font-size: 22px;
      font-weight: 600;
      margin: 4px 0 2px;
    }

    .card-subtext {
      font-size: 11px;
      color: var(--muted);
    }

    /* Circular gauge container */
    .gauge-circle-wrapper {
      margin-top: 6px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .gauge-circle {
      width: 64px;
      height: 64px;
    }

    .gauge-circle svg {
      width: 100%;
      height: 100%;
      transform: rotate(-90deg);
    }

    .gauge-meta {
      font-size: 10px;
      color: var(--muted);
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    /* Mix bar */
    .mix-bar {
      position: relative;
      width: 100%;
      height: 18px;
      border-radius: 999px;
      overflow: hidden;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(30, 64, 175, 0.7);
      margin-top: 4px;
    }

    .mix-segment {
      height: 100%;
      display: inline-block;
    }

    .mix-legend {
      margin-top: 4px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 10px;
      color: var(--muted);
    }

    .mix-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      display: inline-block;
      margin-right: 4px;
    }

    .advisor-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 10px;
    }

    .advisor-card {
      background: #020617;
      border-radius: 16px;
      border: 1px solid var(--border);
      padding: 10px 11px;
      font-size: 11px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .advisor-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2px;
    }

    .advisor-name {
      font-size: 12px;
      font-weight: 500;
    }

    .advisor-rank {
      font-size: 10px;
      color: var(--muted);
    }

    .chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .chip {
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(51, 65, 85, 0.9);
      font-size: 10px;
      color: var(--muted);
    }

    .leaderboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
      gap: 10px;
    }

    .lb-card {
      background: #020617;
      border-radius: 16px;
      border: 1px dashed rgba(148, 163, 184, 0.7);
      padding: 10px 11px;
      font-size: 11px;
    }

    .lb-title {
      font-size: 11px;
      font-weight: 500;
      margin-bottom: 4px;
    }

    .lb-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 2px;
    }

    .lb-row span:first-child {
      color: var(--muted);
    }

    /* Data source panel */
    .data-source-bar {
      margin-top: 18px;
      padding: 10px 12px;
      border-radius: 14px;
      background: radial-gradient(circle at top left, #1f2937 0, #020617 75%);
      border: 1px solid rgba(148, 163, 184, 0.6);
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      font-size: 11px;
      color: var(--muted);
    }

    .data-source-left {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .data-source-title {
      font-size: 12px;
      font-weight: 500;
      color: #e5e7eb;
    }

    .hidden {
      display: none !important;
    }

    .status-pill {
      font-size: 10px;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.9);
      display: inline-flex;
      align-items: center;
      gap: 4px;
      color: var(--muted);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #64748b;
    }

    .status-pill.good .status-dot {
      background: #22c55e;
    }

    .status-pill.bad .status-dot {
      background: #ef4444;
    }

    .status-pill.good {
      border-color: rgba(34, 197, 94, 0.7);
      color: #bbf7d0;
    }

    .status-pill.bad {
      border-color: rgba(248, 113, 113, 0.8);
      color: #fecaca;
    }

    .loading {
      font-size: 11px;
      color: var(--muted);
    }

    .error {
      font-size: 11px;
      color: #fecaca;
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="title-block">
        <div class="badge">
          <span class="pulse-dot"></span>
          BLACKBURN KIA NISSAN GWM
        </div>
        <h1>Advisor Performance ‚Äì Service Dashboard</h1>
        <div class="subtitle">
          One export only: Advisor Summary Performance. Metrics are RO-based (unique InvoiceID), not line-based.
          Warranty / Internal / Customer mix is based on C / W / I closed dates.
        </div>
      </div>

      <div class="header-controls">
        <input type="date" id="datePicker" />
        <select id="advisorFilter">
          <option value="all">All Advisors (&gt;$1k MTD)</option>
        </select>
        <button id="leaderboardToggle">üèÜ Leaderboard</button>
        <button id="insightsBtn">‚ú® Insights</button>
        <button id="reloadOnlineBtn">üîÑ Reload Online Data</button>
      </div>
    </header>

    <div class="top-tabs">
      <button class="top-tab active" data-page="dashboard">Dashboard</button>
      <button class="top-tab" data-page="settings">Settings</button>
    </div>

    <!-- DASHBOARD PAGE -->
    <div id="page-dashboard">
      <!-- TODAY GAUGES -->
      <div class="section-title">Today's performance</div>
      <div id="todaySummary" class="loading">Load CSV to see today's summary.</div>
      <div class="gauge-row" id="todayGauges">
        <!-- Today gauges injected -->
      </div>

      <!-- MTD GAUGES -->
      <div class="section-title">Month-to-date performance</div>
      <div id="mtdSummary" class="loading">Load CSV to see MTD summary.</div>
      <div class="gauge-row" id="mtdGauges">
        <!-- MTD gauges injected -->
      </div>

      <!-- MIX BAR -->
      <div class="section-title">Customer / Warranty / Internal mix (MTD)</div>
      <div class="card">
        <div class="card-header">
          <span class="card-title">RO Mix by type</span>
          <span class="pill" id="mixStatusPill">Snapshot</span>
        </div>
        <div class="card-subtext" id="mixCountsLabel">
          Retail 0 ¬∑ Warranty 0 ¬∑ Internal 0 ¬∑ Total 0
        </div>
        <div class="mix-bar" id="mixBar">
          <!-- segments -->
        </div>
        <div class="mix-legend" id="mixLegend">
          <!-- legend -->
        </div>
      </div>

      <!-- ADVISOR PERFORMANCE -->
      <div class="section-title">Advisor performance</div>
      <div class="card">
        <div class="card-header">
          <span class="card-title">Advisor cards ‚Äì Today &amp; MTD</span>
          <span class="card-subtext" id="advisorFilterNote">
            Filtered by advisors with &gt;$1k MTD labour.
          </span>
        </div>
        <div class="advisor-grid" id="advisorCards">
          <div class="loading">Load CSV to see advisor performance.</div>
        </div>
      </div>

      <!-- LEADERBOARDS -->
      <div class="section-title">Leaderboards &amp; key indicators</div>
      <div class="leaderboard-grid" id="leaderboardCards">
        <!-- populated by JS -->
      </div>

      <!-- DATA SOURCE -->
      <div class="data-source-bar">
        <div class="data-source-left">
          <div class="data-source-title">Data source</div>
          <div>Use the BI Summary export (one row per RO). CSV can be loaded from an online link or manual upload.</div>
        </div>
        <div style="display:flex; flex-wrap:wrap; gap:8px; align-items:center;">
          <input type="file" id="fileInput" accept=".csv" class="hidden" />
          <button id="btnUpload" class="btn-primary">DETAIL DATA (CSV)</button>
          <button id="btnOnlineLoad">üåê Load Online CSV</button>
          <div id="statusTotal" class="status-pill bad">
            <span class="status-dot"></span>
            <span>CSV not loaded</span>
          </div>
        </div>
      </div>
    </div>

    <!-- SETTINGS PAGE (placeholder, JS will wire fields) -->
    <div id="page-settings" class="hidden">
      <div class="section-title">Settings</div>
      <!-- Settings content will be defined in later blocks -->
      <div class="card">
        <div class="card-header">
          <span class="card-title">Targets &amp; data source</span>
        </div>
        <div class="card-subtext">
          Settings UI &amp; storage will be injected by script (Blocks 2‚Äì6).
        </div>
      </div>
    </div>
  </div>
<div class="card">
  <div class="card-header">
    <span class="card-title">Online CSV Source</span>
  </div>

  <div style="margin-top:6px; font-size:11px; color:var(--muted);">
    Paste Google Sheets CSV link (already in Settings & defaults)
  </div>

  <input
    id="onlineCsvUrl"
    type="text"
    style="margin-top:8px; width:100%; padding:8px; border-radius:8px; border:1px solid var(--border); background:#020617; color:var(--text); font-size:11px;"
    value="https://docs.google.com/spreadsheets/d/1fiwosf8gXN6faN-LHQtvAIfMbAagEptqWkwiPE23Vbg/export?format=csv"
  />

  <div id="onlineStatus" style="margin-top:6px; font-size:11px; color:var(--muted);"></div>
</div>

  <!-- INSIGHTS MODAL -->
  <div id="advisorModal" class="hidden">
  <div class="card" style="position:fixed; inset:50% auto auto 50%; transform:translate(-50%, -50%); width:min(520px, 94%); max-height:80vh; overflow-y:auto;">
      <div class="card-header">
        <span class="card-title">Service Advisor Insights</span>
        <span class="pill" id="modalDateLabel">Snapshot</span>
      </div>

      <div id="advisorModalBody" style="font-size:11px; color:var(--muted); margin-top:4px;">
      </div>

      <div style="margin-top:10px; display:flex; justify-content:flex-end; gap:8px;">
        <button id="advisorModalClose">Close</button>
      </div>
  </div>
</div>


  <!-- LEADERBOARD SIDE PANEL -->
  <div id="leaderboardPanel" class="hidden">
    <div style="position:fixed; inset:0; background:rgba(15,23,42,0.7); display:flex; justify-content:flex-end;">
      <div style="width:min(360px, 90%); background:#020617; border-left:1px solid var(--border); padding:12px 14px; display:flex; flex-direction:column; gap:8px;">
        <div class="card-header" style="padding:0;">
          <span class="card-title">Advisor Leaderboard</span>
          <button id="closeLeaderboard" class="icon-btn">‚úï</button>
        </div>
        <div id="leaderboardPanelBody" style="font-size:11px; color:var(--muted); overflow-y:auto; max-height:calc(100vh - 80px);">
          <!-- content injected -->
        </div>
      </div>
    </div>
  </div>

  <!-- SCRIPT WILL START IN BLOCK 2 -->
  <script>
    // Block 2 will insert JS here
  </script>
</body>
</html>
<script>
// === BLOCK 2 ‚Äì STATE, SETTINGS, UTILITIES, METRIC BUILDERS ===

// ----- STATE -----
const state = {
  rows: [],
  loaded: false,
  error: null,
  filters: {
    date: null,      // JS Date used for daily + MTD month
    advisor: "all",  // "all" or specific advisor
  }
};

const SETTINGS_STORAGE_KEY = "advisorDashSettings_v3";

const defaultSettings = {
  // Targets
  dailyLabourTarget: 17000,
  dailyAvgRoTarget: 410,
  dailyHoursRatioTarget: 1.0,     // Charged / Clocked

  mtdLabourTarget: 390000,
  mtdAvgRoTarget: 430,
  mtdGpPctTarget: 80,
  nonRetailMaxPct: 20,            // Max W+I % of total ROs

  // Data source
  dataSourceMode: "online",       // "online" or "manual"
  onlineCsvUrl:
    "https://docs.google.com/spreadsheets/d/1fiwosf8gXN6faN-LHQtvAIfMbAagEptqWkwiPE23Vbg/export?format=csv"
};

let settings = { ...defaultSettings };

// ----- SETTINGS LOAD / SAVE -----
function loadSettings() {
  try {
    const raw = localStorage.getItem(SETTINGS_STORAGE_KEY);
    if (!raw) return;
    const parsed = JSON.parse(raw);
    settings = { ...defaultSettings, ...parsed };
  } catch (e) {
    console.warn("Failed to load settings, using defaults", e);
    settings = { ...defaultSettings };
  }
}

function saveSettings() {
  try {
    localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
  } catch (e) {
    console.warn("Failed to save settings", e);
  }
}

// ----- UTILITIES -----
function parseAuDate(str) {
  if (!str || typeof str !== "string") return null;
  const trimmed = str.trim();
  if (!trimmed) return null;

  // Accept dd/mm/yyyy, d/m/yy, yyyy-mm-dd etc.
  const parts = trimmed.split(/[\/\-]/);
  if (parts.length < 3) return null;

  let d, m, y;
  // If first part is 4 digits, treat as yyyy-mm-dd
  if (parts[0].length === 4) {
    y = parseInt(parts[0], 10);
    m = parseInt(parts[1], 10);
    d = parseInt(parts[2], 10);
  } else {
    d = parseInt(parts[0], 10);
    m = parseInt(parts[1], 10);
    y = parseInt(parts[2], 10);
    if (y < 100) y += 2000;
  }

  if (!y || !m || !d) return null;
  const dt = new Date(y, m - 1, d);
  return isNaN(dt.getTime()) ? null : dt;
}

function sameDay(d1, d2) {
  return (
    d1.getFullYear() === d2.getFullYear() &&
    d1.getMonth() === d2.getMonth() &&
    d1.getDate() === d2.getDate()
  );
}

function sameMonth(d1, d2) {
  return (
    d1.getFullYear() === d2.getFullYear() &&
    d1.getMonth() === d2.getMonth()
  );
}

function toNumber(value) {
  if (typeof value === "number") return isFinite(value) ? value : 0;
  if (value === null || value === undefined || value === "") return 0;
  const cleaned = String(value).replace(/[^0-9.\-]/g, "");
  const n = parseFloat(cleaned);
  return isNaN(n) ? 0 : n;
}

function formatCurrency(v) {
  return "$" + toNumber(v).toLocaleString("en-AU", {
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  });
}

function formatPercent(v) {
  return toNumber(v).toFixed(1) + "%";
}

function uniq(arr) {
  return [...new Set(arr)];
}

// ----- COLUMN HELPERS FOR SUMMARY EXPORT -----
function getCloseDate(row) {
  // Use whichever closed date exists (C, W, I) as the RO close date.
  const c = parseAuDate(row["C Closed Date"]);
  const w = parseAuDate(row["W Closed Date"]);
  const i = parseAuDate(row["I Closed Date"]);
  // If multiple are somehow present, preference C, then W, then I.
  return c || w || i || null;
}

// C / W / I mix
function classifyRoType(row) {
  const c = row["C Closed Date"];
  const w = row["W Closed Date"];
  const i = row["I Closed Date"];
  if (i && String(i).trim() !== "") return "internal";
  if (w && String(w).trim() !== "") return "warranty";
  if (c && String(c).trim() !== "") return "customer";
  return "unknown";
}

function getGross(row) {
  // Adam: you said column B in your view is the sale / labour gross.
  // In this summary export we‚Äôll treat "Gross" as primary, with "Sale" fallback.
  const gross = toNumber(row["Gross"]);
  if (gross !== 0) return gross;
  // Fallback to Sale - Cost if needed
  const sale = toNumber(row["Sale"]);
  const cost = toNumber(row["Cost"]);
  if (sale || cost) return sale - cost;
  return 0;
}

function getCost(row) {
  // Prefer explicit "Cost" then build from components.
  const cost = toNumber(row["Cost"]);
  if (cost !== 0) return cost;
  const cOpen   = toNumber(row["Cost (Open)"]);
  const cLabour = toNumber(row["Cost (Labour)"]);
  const cParts  = toNumber(row["Cost (Parts)"]);
  return cOpen + cLabour + cParts;
}

function getChargedHours(row) {
  return toNumber(row["Charged Hrs"]);
}

function getClockedHours(row) {
  return toNumber(row["Clocked Hrs"]);
}

// ----- DATA PREP AFTER CSV LOAD -----
function initDateFromData() {
  const datePicker = document.getElementById("datePicker");
  if (!state.rows.length || !datePicker) return;

  const dates = state.rows
    .map(r => getCloseDate(r))
    .filter(d => d instanceof Date && !isNaN(d));

  if (!dates.length) return;

  let minD = dates[0];
  let maxD = dates[0];
  dates.forEach(d => {
    if (d < minD) minD = d;
    if (d > maxD) maxD = d;
  });

  // Default filter date = most recent close date
  state.filters.date = new Date(
    maxD.getFullYear(),
    maxD.getMonth(),
    maxD.getDate()
  );

  function toInputDate(d) {
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const dd = String(d.getDate()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd}`;
  }

  datePicker.min = toInputDate(minD);
  datePicker.max = toInputDate(maxD);
  datePicker.value = toInputDate(maxD);
}

function initAdvisorFilter() {
  const select = document.getElementById("advisorFilter");
  if (!select) return;

  const names = uniq(
    state.rows
      .map(r => String(r["Advisor Name"] || "").trim())
      .filter(Boolean)
  ).sort((a, b) => a.localeCompare(b));

  select.innerHTML =
    `<option value="all">All Advisors (&gt;$1k MTD)</option>` +
    names.map(n => `<option value="${n}">${n}</option>`).join("");
}

// ----- FILTERED ROW HELPERS -----
function getRowsForToday() {
  const baseDate = state.filters.date || new Date();
  return state.rows.filter(r => {
    const closed = getCloseDate(r);
    if (!closed) return false;
    return sameDay(closed, baseDate);
  });
}

function getRowsForMtd() {
  const baseDate = state.filters.date || new Date();
  return state.rows.filter(r => {
    const closed = getCloseDate(r);
    if (!closed) return false;
    return sameMonth(closed, baseDate);
  });
}

function getRowsForMtdByAdvisor(advisorName) {
  const baseDate = state.filters.date || new Date();
  return state.rows.filter(r => {
    const closed = getCloseDate(r);
    if (!closed) return false;
    if (!sameMonth(closed, baseDate)) return false;
    if (!advisorName) return true;
    const a = String(r["Advisor Name"] || "").trim();
    return a === advisorName;
  });
}

// ----- ADVISOR STATS (PER ROW SET) -----
function buildAdvisorStats(rows) {
  const byAdvisor = {};

  rows.forEach(r => {
    const name = String(r["Advisor Name"] || "").trim() || "Unknown";
    if (!byAdvisor[name]) {
      byAdvisor[name] = {
        advisor: name,
        labourGross: 0,
        cost: 0,
        roCount: 0,
        chargedHrs: 0,
        clockedHrs: 0
      };
    }

    const g = getGross(r);
    const c = getCost(r);
    const ch = getChargedHours(r);
    const cl = getClockedHours(r);

    byAdvisor[name].labourGross += g;
    byAdvisor[name].cost += c;
    byAdvisor[name].roCount += 1;
    byAdvisor[name].chargedHrs += ch;
    byAdvisor[name].clockedHrs += cl;
  });

  const arr = Object.values(byAdvisor);

  arr.forEach(a => {
    a.avgRo = a.roCount ? a.labourGross / a.roCount : 0;
    a.gpPct = a.labourGross
      ? ((a.labourGross - a.cost) / a.labourGross) * 100
      : 0;
    a.hoursRatio = a.clockedHrs ? (a.chargedHrs / a.clockedHrs) : 0;
  });

  // Sort by labour gross desc by default
  arr.sort((a, b) => b.labourGross - a.labourGross);
  return arr;
}

// ----- METRICS: TODAY -----
function computeTodayMetrics() {
  const allRows = getRowsForToday();
  const { advisor } = state.filters;

  const rows = advisor === "all"
    ? allRows
    : allRows.filter(r => String(r["Advisor Name"] || "").trim() === advisor);

  let totalGross = 0;
  let totalCost = 0;
  let roCount = 0;
  let chargedHrs = 0;
  let clockedHrs = 0;

  let retailCount = 0;
  let warrantyCount = 0;
  let internalCount = 0;

  rows.forEach(r => {
    const g = getGross(r);
    const c = getCost(r);
    const ch = getChargedHours(r);
    const cl = getClockedHours(r);

    totalGross += g;
    totalCost += c;
    roCount += 1;
    chargedHrs += ch;
    clockedHrs += cl;

    const t = classifyRoType(r);
    if (t === "customer") retailCount++;
    else if (t === "warranty") warrantyCount++;
    else if (t === "internal") internalCount++;
  });

  const advisorStats = buildAdvisorStats(rows);

  return {
    rows,
    advisorStats,
    totalGross,
    totalCost,
    roCount,
    chargedHrs,
    clockedHrs,
    retailCount,
    warrantyCount,
    internalCount
  };
}

// ----- METRICS: MTD -----
function computeMtdMetrics() {
  const allRows = getRowsForMtd();
  const { advisor } = state.filters;

  const rows = advisor === "all"
    ? allRows
    : allRows.filter(r => String(r["Advisor Name"] || "").trim() === advisor);

  let totalGross = 0;
  let totalCost = 0;
  let roCount = 0;
  let chargedHrs = 0;
  let clockedHrs = 0;

  let retailCount = 0;
  let warrantyCount = 0;
  let internalCount = 0;

  rows.forEach(r => {
    const g = getGross(r);
    const c = getCost(r);
    const ch = getChargedHours(r);
    const cl = getClockedHours(r);

    totalGross += g;
    totalCost += c;
    roCount += 1;
    chargedHrs += ch;
    clockedHrs += cl;

    const t = classifyRoType(r);
    if (t === "customer") retailCount++;
    else if (t === "warranty") warrantyCount++;
    else if (t === "internal") internalCount++;
  });

  const advisorStatsRaw = buildAdvisorStats(rows);

  // Filter out "ghost advisors" ‚Äì only keep ‚â• $1k MTD labour
  const advisorStats = advisorStatsRaw.filter(a => a.labourGross >= 1000);

  // Build rank map for MTD (for cards + leaderboard side panel)
  const rankMap = {};
  advisorStats
    .slice() // ensure we don't mutate original
    .sort((a, b) => b.labourGross - a.labourGross)
    .forEach((a, idx) => {
      rankMap[a.advisor] = idx + 1;
    });

  const gpPct = totalGross
    ? ((totalGross - totalCost) / totalGross) * 100
    : 0;

  // Non-retail mix
  const nonRetailCount = warrantyCount + internalCount;
  const totalCount = retailCount + warrantyCount + internalCount;
  const nonRetailPct = totalCount
    ? (nonRetailCount / totalCount) * 100
    : 0;

  return {
    rows,
    advisorStats,
    rankMap,
    totalGross,
    totalCost,
    roCount,
    chargedHrs,
    clockedHrs,
    retailCount,
    warrantyCount,
    internalCount,
    gpPct,
    nonRetailPct
  };
}

// ----- MIX METRICS (MTD, all advisors) -----
function computeMtdMixAllAdvisors() {
  const rows = getRowsForMtd();
  let retailCount = 0;
  let warrantyCount = 0;
  let internalCount = 0;

  rows.forEach(r => {
    const t = classifyRoType(r);
    if (t === "customer") retailCount++;
    else if (t === "warranty") warrantyCount++;
    else if (t === "internal") internalCount++;
  });

  const total = retailCount + warrantyCount + internalCount;
  const retailPct = total ? (retailCount / total) * 100 : 0;
  const warrantyPct = total ? (warrantyCount / total) * 100 : 0;
  const internalPct = total ? (internalCount / total) * 100 : 0;

  return {
    retailCount,
    warrantyCount,
    internalCount,
    total,
    retailPct,
    warrantyPct,
    internalPct
  };
}
</script>
<script>
// === BLOCK 3 ‚Äì CIRCULAR GAUGES + MIX BAR RENDERING ===

// Small helper to clamp a value
function clamp(val, min, max) {
  return Math.max(min, Math.min(max, val));
}

// Renders a circular gauge into a card container
// containerId: element ID (e.g. "todayLabourGauge")
// opts: { title, subtitle, valueLabel, targetLabel, ratio, status }
function renderGaugeCard(containerId, opts) {
  const el = document.getElementById(containerId);
  if (!el) return;

  const {
    title,
    subtitle,
    valueLabel,
    targetLabel,
    ratio,
    status // "good" | "attention" | "snapshot"
  } = opts;

  const pct = clamp((ratio || 0) * 100, 0, 200); // allow up to 200% for over-achievement

  let statusLabel = "Snapshot";
  let statusClass = "pill-snapshot";
  if (status === "good") {
    statusLabel = "On track";
    statusClass = "pill-good";
  } else if (status === "attention") {
    statusLabel = "Attention";
    statusClass = "pill-bad";
  }

  el.innerHTML = `
    <div class="gauge-card-inner">
      <div class="gauge-header">
        <div class="gauge-title">${title}</div>
        <div class="gauge-pill ${statusClass}">${statusLabel}</div>
      </div>
      <div class="gauge-sub">${subtitle || ""}</div>
      <div class="gauge-body">
        <div class="circle-gauge" style="--value:${pct};">
          <div class="circle-gauge-outer">
            <div class="circle-gauge-fill"></div>
            <div class="circle-gauge-inner">
              <div class="circle-gauge-value">${valueLabel}</div>
              <div class="circle-gauge-pct">${pct.toFixed(0)}%</div>
            </div>
          </div>
        </div>
        <div class="gauge-target">
          ${targetLabel || ""}
        </div>
      </div>
    </div>
  `;
}

// TODAY GAUGES
function renderTopGaugesToday(today) {
  const {
    totalGross,
    roCount,
    chargedHrs,
    clockedHrs
  } = today;

  const dailyGrossTarget = toNumber(settings.dailyLabourTarget);
  const dailyAvgRoTarget = toNumber(settings.dailyAvgRoTarget);
  const dailyHoursTarget = toNumber(settings.dailyHoursRatioTarget) || 1.0;

  const avgRo = roCount ? totalGross / roCount : 0;
  const hoursRatio = clockedHrs ? (chargedHrs / clockedHrs) : 0;

  // Gauge 1: Today Labour Gross
  renderGaugeCard("todayLabourGauge", {
    title: "Today Labour Gross",
    subtitle: "All advisors ¬∑ closed ROs (InvoiceID)",
    valueLabel: formatCurrency(totalGross),
    targetLabel: dailyGrossTarget
      ? `Target: ${formatCurrency(dailyGrossTarget)}`
      : "Target not set",
    ratio: dailyGrossTarget ? totalGross / dailyGrossTarget : 0,
    status:
      dailyGrossTarget && totalGross >= dailyGrossTarget && roCount
        ? "good"
        : "snapshot"
  });

  // Gauge 2: Today Avg RO
  renderGaugeCard("todayAvgRoGauge", {
    title: "Today Avg RO",
    subtitle: roCount
      ? `Approx labour per RO ¬∑ ${roCount} RO(s)`
      : "No ROs for selected date",
    valueLabel: formatCurrency(avgRo),
    targetLabel: dailyAvgRoTarget
      ? `Target: ${formatCurrency(dailyAvgRoTarget)}`
      : "Target not set",
    ratio: dailyAvgRoTarget ? avgRo / dailyAvgRoTarget : 0,
    status:
      dailyAvgRoTarget && avgRo >= dailyAvgRoTarget && roCount
        ? "good"
        : "snapshot"
  });

  // Gauge 3: Hours Sold / Clocked
  const hoursPctLabel =
    clockedHrs > 0
      ? `${formatPercent(hoursRatio * 100)}`
      : "0.0%";

  renderGaugeCard("todayHoursGauge", {
    title: "Hours Sold / Clocked",
    subtitle: clockedHrs
      ? `Charged ${chargedHrs.toFixed(1)}h ¬∑ Clocked ${clockedHrs.toFixed(1)}h`
      : "No technician hours recorded for today",
    valueLabel: hoursPctLabel,
    targetLabel: `Goal: ${(dailyHoursTarget * 100).toFixed(0)}% billed`,
    ratio: dailyHoursTarget ? hoursRatio / dailyHoursTarget : 0,
    status:
      hoursRatio >= dailyHoursTarget && clockedHrs
        ? "good"
        : "attention"
  });
}

// MTD GAUGES
function renderTopGaugesMtd(mtd) {
  const {
    totalGross,
    roCount,
    gpPct,
    chargedHrs,
    clockedHrs
  } = mtd;

  const mtdGrossTarget   = toNumber(settings.mtdLabourTarget);
  const mtdAvgRoTarget   = toNumber(settings.mtdAvgRoTarget);
  const mtdGpTarget      = toNumber(settings.mtdGpPctTarget) || 80;

  const avgRo = roCount ? totalGross / roCount : 0;

  // Gauge 1: MTD Labour Gross
  renderGaugeCard("mtdLabourGauge", {
    title: "MTD Labour Gross",
    subtitle: roCount
      ? `All advisors ¬∑ ${roCount} RO(s) this month`
      : "No ROs for selected month",
    valueLabel: formatCurrency(totalGross),
    targetLabel: mtdGrossTarget
      ? `Target: ${formatCurrency(mtdGrossTarget)}`
      : "Target not set",
    ratio: mtdGrossTarget ? totalGross / mtdGrossTarget : 0,
    status:
      mtdGrossTarget && totalGross >= mtdGrossTarget
        ? "good"
        : "snapshot"
  });

  // Gauge 2: MTD Avg RO
  renderGaugeCard("mtdAvgRoGauge", {
    title: "MTD Avg RO",
    subtitle: roCount
      ? `Approx labour per RO`
      : "No ROs for selected month",
    valueLabel: formatCurrency(avgRo),
    targetLabel: mtdAvgRoTarget
      ? `Target: ${formatCurrency(mtdAvgRoTarget)}`
      : "Target not set",
    ratio: mtdAvgRoTarget ? avgRo / mtdAvgRoTarget : 0,
    status:
      mtdAvgRoTarget && avgRo >= mtdAvgRoTarget && roCount
        ? "good"
        : "snapshot"
  });

  // Gauge 3: MTD GP%
  const gpRatio = mtdGpTarget ? gpPct / mtdGpTarget : 0;
  renderGaugeCard("mtdGpGauge", {
    title: "MTD GP%",
    subtitle: clockedHrs
      ? `Margin on labour gross`
      : "Margin based on Gross / Cost",
    valueLabel: formatPercent(gpPct),
    targetLabel: `Target: ${mtdGpTarget.toFixed(0)}%`,
    ratio: gpRatio,
    status: gpPct >= mtdGpTarget ? "good" : "attention"
  });
}

// CUSTOMER / WARRANTY / INTERNAL MIX
function renderMixCard(mixMetrics) {
  const barEl   = document.getElementById("mixBar");
  const labelEl = document.getElementById("mixCountsLabel");
  if (!barEl || !labelEl) return;

  const {
    retailCount,
    warrantyCount,
    internalCount,
    total,
    retailPct,
    warrantyPct,
    internalPct
  } = mixMetrics;

  if (!total) {
    barEl.innerHTML = `<div class="mix-empty">No MTD ROs available for mix.</div>`;
    labelEl.textContent = "Retail 0 ¬∑ Warranty 0 ¬∑ Internal 0 ¬∑ Total 0";
    return;
  }

  const retailWidth   = clamp(retailPct,   0, 100);
  const warrantyWidth = clamp(warrantyPct, 0, 100);
  const internalWidth = clamp(internalPct, 0, 100);

  barEl.innerHTML = `
    <div class="mix-segment mix-retail"
         style="flex-basis:${retailWidth}%;"
         title="Retail ${retailCount} (${retailPct.toFixed(1)}%)"></div>
    <div class="mix-segment mix-warranty"
         style="flex-basis:${warrantyWidth}%;"
         title="Warranty ${warrantyCount} (${warrantyPct.toFixed(1)}%)"></div>
    <div class="mix-segment mix-internal"
         style="flex-basis:${internalWidth}%;"
         title="Internal ${internalCount} (${internalPct.toFixed(1)}%)"></div>
  `;

  labelEl.textContent =
    `Retail ${retailCount} (${retailPct.toFixed(1)}%) ¬∑ ` +
    `Warranty ${warrantyCount} (${warrantyPct.toFixed(1)}%) ¬∑ ` +
    `Internal ${internalCount} (${internalPct.toFixed(1)}%) ¬∑ ` +
    `Total ${total}`;
}
</script>
<script>
// === BLOCK 4 ‚Äì ADVISOR CARDS + LEADERBOARDS + RENDER ENGINE ===

// ----- ADVISOR CARDS -----
function renderAdvisorCards(today, mtd) {
  const container = document.getElementById("advisorCards");
  if (!container) return;

  container.innerHTML = "";

  // Merge advisor stats (today + MTD)
  const map = {};

  // Today stats
  today.advisorStats.forEach(a => {
    const name = a.advisor;
    if (!map[name]) {
      map[name] = {
        advisor: name,
        todayGross: 0,
        todayROs: 0,
        todayAvg: 0,
        mtdGross: 0,
        mtdROs: 0,
        mtdAvg: 0,
        leakage: 0,
        gp: 0,
        rank: null
      };
    }
    map[name].todayGross = a.labourGross;
    map[name].todayROs   = a.roCount;
    map[name].todayAvg   = a.avgRo;
  });

  // MTD stats (only advisors > $1k MTD)
  mtd.advisorStats.forEach(a => {
    const name = a.advisor;
    if (!map[name]) {
      map[name] = {
        advisor: name,
        todayGross: 0,
        todayROs: 0,
        todayAvg: 0,
        mtdGross: 0,
        mtdROs: 0,
        mtdAvg: 0,
        leakage: 0,
        gp: 0,
        rank: null
      };
    }
    map[name].mtdGross = a.labourGross;
    map[name].mtdROs   = a.roCount;
    map[name].mtdAvg   = a.avgRo;
    map[name].leakage  = a.hoursRatio ? (1 - a.hoursRatio) * 100 : 0;
    map[name].gp       = a.gpPct;
    map[name].rank     = mtd.rankMap[a.advisor] || null;
  });

  const advisors = Object.values(map)
    .filter(a => a.mtdGross >= 1000)   // Ghost advisor filter
    .sort((a, b) => b.mtdGross - a.mtdGross);

  if (!advisors.length) {
    container.innerHTML =
      `<div class="loading">No advisors meet the MTD >$1,000 requirement.</div>`;
    return;
  }

  advisors.forEach(a => {
    const card = document.createElement("div");
    card.className = "advisor-card";

    card.innerHTML = `
      <div class="advisor-header">
        <div class="advisor-name">${a.advisor}</div>
        <div class="advisor-rank">${a.rank ? `Rank #${a.rank}` : ""}</div>
      </div>

      <div class="chip-row">
        <div class="chip">Today: ${formatCurrency(a.todayGross)}</div>
        <div class="chip">MTD: ${formatCurrency(a.mtdGross)}</div>
        <div class="chip">Avg RO: ${formatCurrency(a.mtdAvg)}</div>
      </div>

      <div class="chip-row">
        <div class="chip">ROs: ${a.mtdROs}</div>
        <div class="chip">Leakage: ${formatPercent(a.leakage)}</div>
        <div class="chip">GP%: ${formatPercent(a.gp)}</div>
      </div>
    `;

    // Clicking card opens insights modal
    card.addEventListener("click", () => {
      openInsightsModal(a.advisor); // will be defined in Block 6
    });

    container.appendChild(card);
  });
}

// ----- LEADERBOARDS -----
function renderLeaderboards(mtd) {
  const container = document.getElementById("leaderboardCards");
  if (!container) return;

  container.innerHTML = "";

  const advisors = mtd.advisorStats.slice();

  if (!advisors.length) {
    container.innerHTML = `<div class="loading">No advisor data available.</div>`;
    return;
  }

  // Sorts
  const topGross = advisors.slice().sort((a,b) => b.labourGross - a.labourGross).slice(0,5);
  const topAvgRo = advisors.slice().sort((a,b) => b.avgRo - a.avgRo).slice(0,5);
  const lowestLeak = advisors.slice().sort((a,b) => a.leakagePct - b.leakagePct).slice(0,5);

  // Convert to simple rows
  function lbCard(title, rows) {
    const card = document.createElement("div");
    card.className = "lb-card";

    let html = `<div class="lb-title">${title}</div>`;
    rows.forEach(r => {
      html += `
        <div class="lb-row">
          <span>${r.advisor}</span>
          <span>${formatCurrency(r.labourGross)}</span>
        </div>
      `;
    });

    card.innerHTML = html;
    return card;
  }

  // Add cards
  container.appendChild(lbCard("Top 5 Labour Gross", topGross));

  const lbAvg = document.createElement("div");
  lbAvg.className = "lb-card";
  lbAvg.innerHTML = `
    <div class="lb-title">Top Avg RO</div>
    ${topAvgRo
      .map(r => `<div class="lb-row"><span>${r.advisor}</span><span>${formatCurrency(r.avgRo)}</span></div>`).join("")}
  `;
  container.appendChild(lbAvg);

  const lbLeak = document.createElement("div");
  lbLeak.className = "lb-card";
  lbLeak.innerHTML = `
    <div class="lb-title">Lowest Leakage</div>
    ${lowestLeak
      .map(r => `<div class="lb-row"><span>${r.advisor}</span><span>${formatPercent(r.leakagePct)}</span></div>`).join("")}
  `;
  container.appendChild(lbLeak);

  // Warranty & Internal Open ROs
  const openWarranty = mtd.rows.filter(r => classifyRoType(r) === "warranty");
  const openInternal = mtd.rows.filter(r => classifyRoType(r) === "internal");

  const lbWarranty = document.createElement("div");
  lbWarranty.className = "lb-card";
  lbWarranty.innerHTML = `
    <div class="lb-title">Warranty ROs</div>
    <div>${openWarranty.length} total</div>
  `;
  container.appendChild(lbWarranty);

  const lbInternal = document.createElement("div");
  lbInternal.className = "lb-card";
  lbInternal.innerHTML = `
    <div class="lb-title">Internal ROs</div>
    <div>${openInternal.length} total</div>
  `;
  container.appendChild(lbInternal);
}

// ----- LEADERBOARD PANEL -----
function openLeaderboardPanel(mtd) {
  const panel = document.getElementById("leaderboardPanel");
  const body  = document.getElementById("leaderboardPanelBody");
  const close = document.getElementById("closeLeaderboard");

  if (!panel || !body || !close) return;

  const advisors = mtd.advisorStats.slice().sort((a,b) => b.labourGross - a.labourGross);

  body.innerHTML = advisors
    .map(a => `
      <div class="lb-row">
        <span>${a.rank ? "#" + a.rank : ""} ${a.advisor}</span>
        <span>${formatCurrency(a.labourGross)}</span>
      </div>
    `)
    .join("");

  panel.classList.remove("hidden");
  close.addEventListener("click", () => {
    panel.classList.add("hidden");
  });
}

// ----- DASHBOARD RENDER PROCESS -----
function renderDashboard() {
  if (!state.loaded) {
    document.getElementById("todaySummary").textContent = "CSV not loaded.";
    document.getElementById("mtdSummary").textContent   = "CSV not loaded.";
    return;
  }

  const today = computeTodayMetrics();
  const mtd   = computeMtdMetrics();
  const mix   = computeMtdMixAllAdvisors();

  // Today summary line
  document.getElementById("todaySummary").textContent =
    `ROs Today: ${today.roCount} ¬∑ Gross: ${formatCurrency(today.totalGross)}`;

  // MTD summary line
  document.getElementById("mtdSummary").textContent =
    `MTD ROs: ${mtd.roCount} ¬∑ Gross: ${formatCurrency(mtd.totalGross)}`;

  // Gauges
  renderTopGaugesToday(today);
  renderTopGaugesMtd(mtd);

  // Mix
  renderMixCard(mix);

  // Advisor cards
  renderAdvisorCards(today, mtd);

  // Leaderboards
  renderLeaderboards(mtd);

  // Wire leaderboard button
  const leaderboardBtn = document.getElementById("leaderboardToggle");
  if (leaderboardBtn) {
    leaderboardBtn.onclick = () => openLeaderboardPanel(mtd);
  }
}

// ----- PAGE SWITCHING -----
document.querySelectorAll(".top-tab").forEach(btn => {
  btn.addEventListener("click", () => {
    document.querySelectorAll(".top-tab").forEach(b =>
      b.classList.remove("active")
    );
    btn.classList.add("active");

    const page = btn.dataset.page;
    document.getElementById("page-dashboard").classList.add("hidden");
    document.getElementById("page-settings").classList.add("hidden");
    document.getElementById(`page-${page}`).classList.remove("hidden");
  });
});
</script>
<script>
// === BLOCK 5 ‚Äì CSV LOADING + FILTER WIRING ===

// Safe accessor for global state
function getAdvisorState() {
  if (typeof state !== "undefined") return state;
  if (!window.__advisorState) {
    window.__advisorState = {
      rows: [],
      loaded: false,
      filters: { date: null, advisor: "all" }
    };
  }
  return window.__advisorState;
}

// Local helper: parse AU date (for C Closed Date default)
function parseCClosedDate(raw) {
  if (!raw) return null;
  // Try DD/MM/YYYY first
  const m1 = String(raw).match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})$/);
  if (m1) {
    const d = parseInt(m1[1], 10);
    const m = parseInt(m1[2], 10);
    let y = parseInt(m1[3], 10);
    if (y < 100) y += 2000;
    const dt = new Date(y, m - 1, d);
    return isNaN(dt.getTime()) ? null : dt;
  }
  // Fallback to Date()
  const dt = new Date(raw);
  return isNaN(dt.getTime()) ? null : dt;
}

// ---- INGEST CSV ROWS INTO STATE ----
function ingestAdvisorCsvRows(rows) {
  const s = getAdvisorState();

  // Filter out empty rows: keep ones with InvoiceID or Advisor Name
  const clean = (rows || []).filter(r =>
    r &&
    (r["InvoiceID"] || r["Advisor Name"])
  );

  s.rows = clean;
  s.loaded = true;

  // Build advisor dropdown (unique names)
  const advisorSelect = document.getElementById("advisorFilter");
  if (advisorSelect) {
    const names = [...new Set(
      clean
        .map(r => String(r["Advisor Name"] || "").trim())
        .filter(Boolean)
    )].sort((a, b) => a.localeCompare(b));

    advisorSelect.innerHTML =
      `<option value="all">All Advisors</option>` +
      names.map(n => `<option value="${n}">${n}</option>`).join("");
  }

  // Determine min/max C Closed Date
  const cDates = clean
    .map(r => parseCClosedDate(r["C Closed Date"]))
    .filter(d => d instanceof Date && !isNaN(d));

  const datePicker = document.getElementById("datePicker");
  if (cDates.length && datePicker) {
    let minD = cDates[0];
    let maxD = cDates[0];
    cDates.forEach(d => {
      if (d < minD) minD = d;
      if (d > maxD) maxD = d;
    });

    function toInput(d) {
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${dd}`;
    }

    datePicker.min = toInput(minD);
    datePicker.max = toInput(maxD);
    datePicker.value = toInput(maxD);

    // Set filter date in state
    s.filters.date = new Date(
      maxD.getFullYear(),
      maxD.getMonth(),
      maxD.getDate()
    );
  }

  // Update status pill
  const statusTotal = document.getElementById("statusTotal");
  if (statusTotal) {
    statusTotal.classList.remove("bad");
    statusTotal.classList.add("good");
    statusTotal.innerHTML =
      '<span class="status-dot"></span><span>Total performance: Loaded ‚úî</span>';
  }

  // Finally, re-render dashboard
  try {
    renderDashboard();
  } catch (e) {
    console.error("renderDashboard error:", e);
  }
}

// ---- PARSE CSV TEXT ----
function parseAdvisorCsvText(text) {
  try {
    const result = Papa.parse(text, {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: true
    });
    ingestAdvisorCsvRows(result.data || []);
  } catch (e) {
    console.error("CSV parse failed:", e);
    const statusTotal = document.getElementById("statusTotal");
    if (statusTotal) {
      statusTotal.classList.remove("good");
      statusTotal.classList.add("bad");
      statusTotal.innerHTML =
        '<span class="status-dot"></span><span>Failed to parse CSV</span>';
    }
  }
}

// ---- FILE UPLOAD HANDLER ----
function handleAdvisorFileUpload(file) {
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    parseAdvisorCsvText(ev.target.result);
  };
  reader.onerror = () => {
    console.error("File read error");
    const statusTotal = document.getElementById("statusTotal");
    if (statusTotal) {
      statusTotal.classList.remove("good");
      statusTotal.classList.add("bad");
      statusTotal.innerHTML =
        '<span class="status-dot"></span><span>Error reading file</span>';
    }
  };
  reader.readAsText(file);
}

// ---- ONLINE CSV LOAD ----
async function loadAdvisorOnlineCsv() {
  const urlInput = document.getElementById("onlineCsvUrl");
  const statusSpan = document.getElementById("onlineStatus");
  const statusTotal = document.getElementById("statusTotal");

  const url = urlInput ? urlInput.value.trim() : "";
  if (!url) {
    if (statusSpan) statusSpan.textContent = "Please enter an online CSV URL.";
    return;
  }

  if (statusSpan) statusSpan.textContent = "Loading online CSV‚Ä¶";

  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error("HTTP " + res.status);
    const text = await res.text();
    parseAdvisorCsvText(text);

    if (statusSpan) statusSpan.textContent = "Online CSV loaded.";
    if (statusTotal) {
      statusTotal.classList.remove("bad");
      statusTotal.classList.add("good");
      statusTotal.innerHTML =
        '<span class="status-dot"></span><span>Total performance: Loaded (online) ‚úî</span>';
    }
  } catch (e) {
    console.error("Online CSV load failed:", e);
    if (statusSpan) statusSpan.textContent = "Failed to load online CSV.";
    if (statusTotal) {
      statusTotal.classList.remove("good");
      statusTotal.classList.add("bad");
      statusTotal.innerHTML =
        '<span class="status-dot"></span><span>Online load failed</span>';
    }
  }
}

// ---- WIRE DOM EVENTS ----
document.addEventListener("DOMContentLoaded", () => {
  const s = getAdvisorState();

const fileInput       = document.getElementById("fileInput");
const btnUploadTotal  = document.getElementById("btnUpload");
  const btnOnlineLoad   = document.getElementById("btnOnlineLoad");
  const reloadOnlineBtn = document.getElementById("reloadOnlineBtn");
  const advisorFilter   = document.getElementById("advisorFilter");
  const datePicker      = document.getElementById("datePicker");
  const dataSourceMode  = document.getElementById("dataSourceMode");

  // Upload button -> open file dialog
  if (btnUploadTotal && fileInput) {
    btnUploadTotal.addEventListener("click", () => fileInput.click());
  }

  // File chosen -> parse
  if (fileInput) {
    fileInput.addEventListener("change", () => {
      if (fileInput.files && fileInput.files[0]) {
        handleAdvisorFileUpload(fileInput.files[0]);
      }
    });
  }

  // Online CSV test/load button (in Settings)
  if (btnOnlineLoad) {
    btnOnlineLoad.addEventListener("click", () => {
      loadAdvisorOnlineCsv();
    });
  }

  // Reload Online Data button in header
  if (reloadOnlineBtn) {
    reloadOnlineBtn.addEventListener("click", () => {
      loadAdvisorOnlineCsv();
    });
  }

  // Advisor filter
  if (advisorFilter) {
    advisorFilter.addEventListener("change", () => {
      s.filters.advisor = advisorFilter.value || "all";
      if (s.loaded) {
        renderDashboard();
      }
    });
  }

  // Date filter
  if (datePicker) {
    datePicker.addEventListener("change", () => {
      if (datePicker.value) {
        const d = new Date(datePicker.value);
        s.filters.date = new Date(
          d.getFullYear(),
          d.getMonth(),
          d.getDate()
        );
      } else {
        s.filters.date = null;
      }
      if (s.loaded) {
        renderDashboard();
      }
    });
  }

  // If mode is "online", try auto-load at startup (optional)
  if (dataSourceMode && dataSourceMode.value === "online") {
    const urlInput = document.getElementById("onlineCsvUrl");
    if (urlInput && urlInput.value.trim()) {
      loadAdvisorOnlineCsv();
    }
  }
});
</script>
<script>
// === BLOCK 6 ‚Äì INSIGHTS ENGINE + MODAL + GLOBAL INSIGHTS ===

// ---------- INSIGHTS LOGIC ----------

function buildAdvisorInsights(advisor, stats, today, mtd, mix) {
  const {
    mtdGross,
    mtdAvg,
    mtdROs,
    leakage,
    gp,
    todayGross,
    todayROs,
    todayAvg
  } = stats;

  const dealershipAvgRo = mtd.avgRo || 0;
  const dealershipLeak  = mtd.avgLeak || 0;
  const dealershipGp    = mtd.avgGpPct || 0;

  const items = [];

  // --- Strengths ---
  if (mtdAvg > dealershipAvgRo) {
    items.push(`‚Ä¢ Strong RO average (${formatCurrency(mtdAvg)} vs store ${formatCurrency(dealershipAvgRo)}).`);
  }
  if (gp >= dealershipGp) {
    items.push(`‚Ä¢ GP% is above store average (${formatPercent(gp)} vs ${formatPercent(dealershipGp)}).`);
  }
  if (leakage < dealershipLeak) {
    items.push(`‚Ä¢ Excellent hour control (leakage ${formatPercent(leakage)} vs ${formatPercent(dealershipLeak)}).`);
  }
  if (mtdGross > 10000) {
    items.push(`‚Ä¢ Solid overall contribution with ${formatCurrency(mtdGross)} MTD.`);
  }

  // --- Opportunities ---
  if (mtdAvg < dealershipAvgRo) {
    items.push(`‚Ä¢ Raise Avg RO ‚Äî currently ${formatCurrency(mtdAvg)}, store is ${formatCurrency(dealershipAvgRo)}.`);
  }
  if (gp < dealershipGp) {
    items.push(`‚Ä¢ Lift GP% ‚Äî currently ${formatPercent(gp)}, store is ${formatPercent(dealershipGp)}.`);
  }
  if (leakage > 20) {
    items.push(`‚Ä¢ Hours leakage high at ${formatPercent(leakage)} ‚Äî aim under 20%.`);
  }
  if (mtdROs < 15) {
    items.push(`‚Ä¢ Low RO count (${mtdROs}). Increase throughput on customer-pay work.`);
  }

  // --- Today vs MTD comparison ---
  if (todayGross && todayGross < todayAvg) {
    items.push(`‚Ä¢ Today‚Äôs RO average is soft ‚Äî ${formatCurrency(todayAvg)}. Push additional items/declined work follow-up.`);
  }

  // --- Mix-based insights ---
  if (mix.retailPct < 40) {
    items.push(`‚Ä¢ Retail mix low (${mix.retailPct.toFixed(1)}%). More customer-pay opportunities needed.`);
  }
  if (mix.warrantyPct > 25) {
    items.push(`‚Ä¢ Warranty ratio high (${mix.warrantyPct.toFixed(1)}%). Confirm labour ops coded correctly.`);
  }

  // If nothing meaningful, fallback:
  if (!items.length) {
    items.push("‚Ä¢ Performance steady and consistent. Maintain rhythm.");
  }

  return items.join("<br>");
}

// ---------- PER-ADVISOR MODAL ----------

function openInsightsModal(advisorName) {
  const modal  = document.getElementById("advisorModal");
  const body   = document.getElementById("advisorModalBody");
  const close  = document.getElementById("advisorModalClose");

  const today = computeTodayMetrics();
  const mtd   = computeMtdMetrics();
  const mix   = computeMtdMixAllAdvisors();

  // Find advisor stats
  const statsToday = today.advisorStats.find(a => a.advisor === advisorName) || {
    labourGross: 0, roCount: 0, avgRo: 0
  };
  const statsMtd = mtd.advisorStats.find(a => a.advisor === advisorName) || {
    labourGross: 0, roCount: 0, avgRo: 0, leakagePct: 0, gpPct: 0
  };

  const insights = buildAdvisorInsights(
    advisorName,
    {
      todayGross: statsToday.labourGross,
      todayAvg: statsToday.avgRo,
      todayROs: statsToday.roCount,
      mtdGross: statsMtd.labourGross,
      mtdAvg: statsMtd.avgRo,
      mtdROs: statsMtd.roCount,
      leakage: statsMtd.leakagePct,
      gp: statsMtd.gpPct
    },
    today,
    mtd,
    mix
  );

  body.innerHTML = `
    <h2>${advisorName}</h2>
    <div class="modal-section">
      <h3>Performance Summary</h3>
      <p><strong>Today:</strong> ${formatCurrency(statsToday.labourGross)} ¬∑ ${statsToday.roCount} ROs ¬∑ Avg ${formatCurrency(statsToday.avgRo)}</p>
      <p><strong>MTD:</strong> ${formatCurrency(statsMtd.labourGross)} ¬∑ ${statsMtd.roCount} ROs ¬∑ Avg ${formatCurrency(statsMtd.avgRo)}</p>
      <p><strong>Leakage:</strong> ${formatPercent(statsMtd.leakagePct)}</p>
      <p><strong>GP%:</strong> ${formatPercent(statsMtd.gpPct)}</p>
    </div>

    <div class="modal-section">
      <h3>Insights</h3>
      <p>${insights}</p>
    </div>
  `;

  modal.classList.remove("hidden");

  close.onclick = () => modal.classList.add("hidden");
}

// ---------- GLOBAL INSIGHTS (WHOLE DEALERSHIP) ----------

function renderGlobalInsights() {
  const el = document.getElementById("insightsContent");
  if (!el) return;

  const today = computeTodayMetrics();
  const mtd   = computeMtdMetrics();
  const mix   = computeMtdMixAllAdvisors();

  const lines = [];

  // Daily summary
  if (today.totalGross < toNumber(settings.dailyLabourTarget)) {
    lines.push(`‚Ä¢ Today‚Äôs gross ${formatCurrency(today.totalGross)} is behind target. Consider calling declined work.`);
  } else {
    lines.push(`‚Ä¢ Today‚Äôs gross ${formatCurrency(today.totalGross)} is ahead of pace. Good job keeping RO flow moving.`);
  }

  // MTD Gross
  if (mtd.totalGross < toNumber(settings.mtdLabourTarget)) {
    lines.push(`‚Ä¢ MTD Gross ${formatCurrency(mtd.totalGross)} is below target. Accelerate follow-up on open Customer-Pay work.`);
  } else {
    lines.push(`‚Ä¢ MTD Gross ${formatCurrency(mtd.totalGross)} is tracking well.`);  
  }

  // Mix
  if (mix.retailPct < 50) {
    lines.push(`‚Ä¢ Retail mix is soft (${mix.retailPct.toFixed(1)}%). Push menu presentation and declined work pickup.`);
  }

  if (mix.warrantyPct > 25) {
    lines.push(`‚Ä¢ Warranty %. Consider reviewing operation coding and ensure warranty isn't masking retail opportunities.`);
  }

  if (mix.internalPct > 20) {
    lines.push(`‚Ä¢ Internal work high (${mix.internalPct.toFixed(1)}%). Check if booking capacity is being eaten by reconditioning.`);
  }

  // Fallback
  if (!lines.length) lines.push("‚Ä¢ Performance steady. Maintain momentum.");

  el.innerHTML = lines.join("<br>");
}


// ---------- FINAL RENDER HOOK ----------

const __oldRenderDashboard = renderDashboard;
renderDashboard = function() {
  __oldRenderDashboard();
  renderGlobalInsights();
};

</script>
